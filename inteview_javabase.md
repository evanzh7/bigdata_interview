## java 基础  

1. hashmap的底层实现，如何处理冲突，采用链表存储同一个hash值的元素，对于什么操作会有影响。

	底层实现是数组，数组中的对象是Entry类对象。  
	当存在冲突时，将具有相同hashcode的对象挂载在相同槽内，组成链。采用头插法，新插入对象放在链头，最先加入的对象放在链尾。  
	**hashcode()**  
	**indexFor()**  
	**put()**  
	**get()**  
	**addEntry()**  
	**loadfactor**  
	loadfactor=元素个数/表长  
	**hash算法**  

	```java
	int indexFor(int h, int length){
		return h&(length - 1)	
	}
	```
	**resize**  
	数组默认大小是16，负载因子默认未0.75  

2. 为何重写hashcode 和 equals方法  
	重写equals方法必然重写hashcode方法，这是java规范。  
	hashcode返回值是一个整数，代表两个对象是否相等。  


3. 异常种类有哪些
	
	![java中常见异常如下图所示](img/exception_1.jpg)  
	Throwable是所有异常的根，java.lang.Throwable  
	Error是错误，java.lang.Error  
	Exception是异常，java.lang.Exception  
	一般分为Checked异常和Runtime异常，所有RuntimeException类及其子类的实例被称为Runtime异常，不属于该范畴的异常则被称为CheckedException。


4. [java 排序算法代码实现](http://www.cnblogs.com/wolf-sun/p/4312475.html)，复杂度、稳定性

5. 浅拷贝 vs 深拷贝

	**浅拷贝**是指拷贝对象时仅仅拷贝对象本身（包括对象中的基本变量），而不拷贝对象包含的引用指向的对象。  
	**深拷贝**不仅拷贝对象本身，而且拷贝对象包含的引用指向的所有对象。  
	若不对clone()方法进行改写，则调用此方法得到的对象即为浅拷贝。  
	[详细解释浅拷贝与深拷贝](http://www.cnblogs.com/shuaiwhu/archive/2010/12/14/2065088.html)  
	当然我们还有一种深拷贝方法，就是将对象串行化。缺点耗时。

6. 怎么判断一个对象该被回收  
	计数法  
	根搜索法

7. hashMap 和 hashtable区别
8. hashtable原理
9. hashtable是怎么实现线程安全的
8. java的代理是怎么实现的
9. 抽象类和接口的区别
10. 接口和实现类的区别
10. java四种引用
11. 集合类介绍，各种集合类之间的区别
12. 继承和组合区别
13. lmbda表达式
14. java 8 新特性
15. java基础数据类型 
	- 整形 byte	short	int		long  
	- 浮点型	float	double  
	- 逻辑型 boolean  
	- 字符型	char  
16. java中的数据存储  

	- 寄存器：最快的存储区，编译器分配，程序无法控制
	- 栈：存放基础数据类型的变量数据 和 对象的引用  
	- 堆：new出来的对象存放位置
	- 静态域：静态成员变量存放位置  
	- 常量池：字符串变凉&基本数据类型变量 public static final  
	- 非rRAM存储：硬盘等永久存储空间
20. 内存溢出 和 内存泄漏
21. 内存敲代码优化，我们都用stringbuffer来代替+号，来减少建立的对象。那么问题来了，除了这个你还用过什么碼代码技巧来节省内存 
22. 方法走完，引用消失，堆内存未必消失，好多人在做报表导出的时候，就会在for循环里不断的创建对象，很容易造成堆溢出，请问这种大文件导出怎么破？  
  建议不要在for里创建对象，可以在外面搞一个对象，for循环里对一个对象修改数据即可。
23. java支持多线程，每个线程有自己的java虚拟机栈和本地方法栈。✔️
24. 新建的实例在堆内存，实例变量也是在堆内存。✔️
25. 入栈和出栈  
	入栈的时候，就是执行一个方法的时候，为这个方法创建一个栈帧入栈。  
	出栈的时候，就是方法执行完毕了。  
26. 加载父类->初始化父类->加载子类  
27. 如果我有一个静态的成员变量int，那我多线程更改是否会有线程安全问题，为什么？
	静态成员变量，它在内存里， 只有一份，就是属于类的。你多个线程并发修改，一定会有并发问题，可能导致数据出错。 
28. 类加载是按需加载，可以一次性加载全部的类吗？
	如果是默认的类加载机制，那么是你得代码运行过程中，遇到什么类加载什么类。  
	如果你要自己加载类，那么需要写自己的类加载器。  
29. 多线程的实现方式有哪些？
    继承 Thread 类、实现Runnable 接口，最后调用 的是 start() 方法来启动线程。  
    start() 跟 run() 方法的区别和联系?  
    直接调用 start() 方法，此时线程处于一个就绪（可运行）的状态，但是并没有真正	的运行。而是得到CPU 的时间片后，开始执行 run() 方法，run() 方法里面的是我们	的线程体。
	我们直接 运行 run() 方法，它其实就是一个普通的方法调用，在主线程中执行，是不会开启多线程的。
30. 死锁   
	**产生死锁的原因主要是**：  
（1） 因为系统资源不足。  
（2） 进程运行推进的顺序不合适。  
（3） 资源分配不当等。   
    **产生死锁的四个必要条件**：  
（1）互斥条件：一个资源每次只能被一个进程使用。  
（2）占有且等待：一个进程因请求资源而阻塞时，对已获得的资源保持不放。   
（3）不可强行占有:进程已获得的资源，在末使用完之前，不能强行剥夺。  
（4）循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。   
这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之
一不满足，就不会发生死锁。 
 
	**处理死锁的基本方法**（银行家算法）：

	- 死锁预防：通过设置某些限制条件，去破坏死锁的四个条件中的一个或几个条件，来预防发生死锁。但由于所施加的限制条件往往太严格，因而导致系统资源利用率和系统吞吐量降低。
	- 死锁避免：允许前三个必要条件，但通过明智的选择，确保永远不会到达死锁点，因此死锁避免比死锁预防允许更多的并发。
	- 死锁检测：不须实现采取任何限制性措施，而是允许系统在运行过程发生死锁，但可通过系统设置的检测机构及时检测出死锁的发生，并精确地确定于死锁相关的进程和资源，然后采取适当的措施，从系统中将已发生的死锁清除掉。
	- 死锁解除：与死锁检测相配套的一种措施。当检测到系统中已发生死锁，需将进程从死锁状态中解脱出来。常用方法：撤销或挂起一些进程，以便回收一些资源，再将这些资源分配给已处于阻塞状态的进程。死锁检测盒解除有可能使系统获得较好的资源利用率和吞吐量，但在实现上难度也最大。

	**处理死锁的基本算法**    
	1. 如果request<=need，转向步骤2；否则认为出错，因为请求资源大于需要资源。
	2. 如果request<=available，转向步骤3,；否则尚无足够资源，进程p阻塞；
	3. 系统尝试为把资源分配给进程P，并修改available、allocation和need的数值。
	4. 系统执行安全性算法，检查此次分配后系统是否处于安全状态，若安全，才正式将资源分配给进程P，否则将本次试探性分配作废，让进程P等待。  
	安全状态：系统能按照某种进程顺序，为每个进程分配资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利完成。
	
31. 线程池  
    newSingleThreadExecutor、  
    newFixedThreadPool、  
    newCachedThreadPool、  
    newScheduledThreadPool  
线程池底层都是通过 ThreadPoolExecutor 来实现的

	```java
	public ThreadPoolExecutor
	( 
	int corePoolSize,                          
	int maximumPoolSize,                         
	long keepAliveTime,                           
	TimeUnit unit,             
	BlockingQueue <Runnable> workQueue,                     
	ThreadFactory  threadFactory,              
	RejectedExecutionHandler handler)
	```
	几个参数的意思分别为：

	- corePoolSize： 线程池里最小线程数
	- maximumPoolSize：线程池里最大线程数量，超过最大线程时候会使用 RejectedExecutionHandler
	- keepAliveTime：线程最大的存活时间，超过这个时间就会被回收
	- unit：线程最大的存活时间的单位
	- workQueue：缓存需要执行的异步任务的队列
	- threadFactory：新建线程工厂
	- handler：拒绝策略，表示当workQueue已满，且池中的线程数达到maximumPoolSize时，线程池拒绝添加新任务时采取的策略。DiscardPolicy：抛弃当前任务，DiscardOldestPolicy：扔掉最旧的，CallerRunsPolicy：由向线程池提交任务的线程来执行该任务，AbortPolicy：抛出 RejectedExecutionException 异常。
32. 这几种线程池在哪些情况下使用什么类型的
33. 如何判断两个对象是否相等